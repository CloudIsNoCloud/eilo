# 2019-8-13

模块的 Singleton（独生）模式指的是调用一个类，任何时候返回的都是同一个实例

早前可以使用顶层对象 `global` 来实现

```JavaScript
// mod.js
function A() {
  this.foo = 'hello';
}

if (!global._foo) {
  global._foo = new A();
}

module.exports = global._foo;

// 然后加载 mod.js
const a = require('./mod.js');
console.log(a.foo);
```

有个弊端是 `global._foo` 可以被任意文件修改的，所以使用 Symbol 来进行改善

```JavaScript
// mod.js
const FOO_KEY = Symbol.for('foo');

function A() {
  this.foo = 'hello';
}

if (!global[FOO_KEY]) {
  global[FOO_KEY] = new A();
}

module.exports = global[FOO_KEY];

// 可以保证 global[FOO_KEY] 不会被无意间覆盖，但还是可以被改写
global[Symbol.for('foo')] = { foo: 'world' };

const a = require('./mod.js');
```

如果将生成方式替换成 `Symbol()` 也就不会被改写了，但是这样，如果多次执行这个脚本，每次得到的 `FOO_KEY` 都是不一样的，虽然 Node 会将脚本的执行结果缓存，一般情况下，不会多次执行同一个脚本，但是用户可以手动清除缓存，所以也不是绝对可靠

ES6 内置了 11 个 Symbol 值

`Symbol.hasInstance`，是对象的一个属性，指向内部的一个方法，当其他对象使用 `instanceof` 运算符，判断是否为该对象的实例时，会调用这个方法，比如，`foo instanceof Foo` 在语言内部，实际调用的是 `Foo[Symbol.hasInstance](foo)`，这么看来，其实 `instanceof` 用来判断一个实例时也还是会被蒙骗的

```JavaScript
class MyClass {
  [Symbol.hasInstance](foo) {
    return foo instanceof Array;
  }
}

[1, 2, 3] instanceof new MyClass() // true

// 另一个例子
class Even {
  static [Symbol.hasInstance](obj) {
    return Number(obj) % 2 === 0;
  }
}

// 等同于
const Even = {
  [Symbol.hasInstance](obj) {
    return Number(obj) % 2 === 0;
  }
};

1 instanceof Even // false
2 instanceof Even // true
12345 instanceof Even // false
```

对象的 `Symbol.isConcatSpreadable` 属性等于一个布尔值，表示该对象用于 `Array.prototype.concat()` 时，是否可以展开，感觉是一个没什么用的属性

```JavaScript
let arr1 = ['c', 'd'];
['a', 'b'].concat(arr1, 'e') // ['a', 'b', 'c', 'd', 'e']
arr1[Symbol.isConcatSpreadable] // undefined

let arr2 = ['c', 'd'];
arr2[Symbol.isConcatSpreadable] = false;
['a', 'b'].concat(arr2, 'e') // ['a', 'b', ['c','d'], 'e']
```

数组的默认行为是可以展开，`Symbol.isConcatSpreadable` 默认等于 `undefined`,该属性等于 `true` 时，也有展开的效果，类似数组的对象正好相反，默认不展开，它的 `Symbol.isConcatSpreadable` 属性设为 `true`，才可以展开

`Symbol.isConcatSpreadable` 属性也可以定义在类里面，并且定义在实例上和定义在类本身效果相同，定义在类本身要采用 `get` 取值器

对象的 `Symbol.species` 属性，指向一个构造函数，创建衍生对象时，会使用该属性，当类中定义了该属性，创建衍生对象时就会使用这个属性返回的函数，作为构造函数，默认返回的是 `this`
