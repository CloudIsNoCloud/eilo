# 2019-7-24

`Ctrl + F2` 是一个很好用的 vscode 快捷键

`let` 用来声明变量，并且只在声明的代码块（由 `{}` 包裹的区域即称之为代码块）有效，所以很适合被用在 `for` 循环中

`for` 循环有个很特别的地方，设置循环变量和条件的部分属于父作用域，而循环体是独立的子作用域

`let` 声明的变量不会发生“变量提升”，也就是不能再变量声明之前使用

“变量提升”会将变量提升至全局或者函数作用域头部，可以是 `var` 声明的变量，也可以是函数，函数会提升至变量之前，这是一个比较常见的面试题，容易绕晕

`var` 声明的变量是全局有效的，但是不能说在函数内部声明了，在外部使用，如果都在最外层声明的话，似乎 `let` 和 `var` 差不多，还需要思考

`let` 会存在“暂时性死区”（TDZ），在作用域内声明变量，这个变量就绑定在了这个区域，将不受外部同名变量的干扰

`let` 和 `const` 不出现“变量提升”以及“暂时性死区”都是为了让开发者习惯使用变量前先声明

对于 ES5 来说，只有全局和函数两个作用域，不存在块级作用域的说法，会导致“变量提升”所带来的变量覆盖问题和循环变量泄露成为全局变量

ES6 中的作用域允许任意嵌套，如同作用域的定义一样，外层作用域不能读取内层作用域中声明的变量，内层作用域可以定义与外层作用域同名的变量形成“暂时性死区”

可以直接使用 `{}` 形成一个块级作用域进行一些逻辑操作，它使得那些匿名立即执行函数不在必要，至于如何使用这一特性，还需一定的思考

在 ES5 中，函数的声明只可放在顶层或函数作用域中声明，在块级作用域中声明是非法的，而 ES6 中，函数的声明类似与 `let`，但是浏览器的实现有所不同，函数是类似与 `var` 的，不仅会提升至全局或函数作用域的头部，还会提升到所在块级作用域的头部

`const` 有很多和 `let` 相同的特性，区别在于 `const` 用于声明常量，必须在声明时就进行初始化，声明后将不可改变其值，但是，如果声明的时是对象类型的常量，`const` 只会保证这个指针是固定的，不保证内部数据不变

`Object` 有一个 `keys` 方法可以用来获取某一对象中的所有 key 值，并返回为一个数组
