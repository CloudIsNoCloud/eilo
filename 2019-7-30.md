# 2019-7-30

新增了 `y`（粘连（sticky））修饰符，用法与 `g` 修饰符类似，都是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始，不同之处在于，`g` 修饰符只要剩余位置中存在匹配就可，而 `y` 修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义，因此，在匹配时，`y` 修饰符确保不会有漏掉的字符

```JavaScript
var s = 'aaa_aa_a';
var r1 = /a+/g;
var r2 = /a+/y;

r1.exec(s) // ["aaa"]
r2.exec(s) // ["aaa"]

r1.exec(s) // ["aa"]
r2.exec(s) // null
```

单单一个 `y` 修饰符对 `match` 方法，只能返回第一个匹配，必须与 `g` 修饰符联用，才能返回所有匹配

```JavaScript
'a1a2a3'.match(/a\d/y) // ["a1"]
'a1a2a3'.match(/a\d/gy) // ["a1", "a2", "a3"]
```

使用 `RegExp.prototype.sticky` 属性可以检查正则对象是否使用了 `y` 修饰符

使用 `RegExp.prototype.flags` 属性会返回正则的修饰符

`s` 修饰符表示 `dotAll` 模式，也就是使得 `.` 能够代表一切的单个字符，甚至是 `u` 模式下无法匹配的行终止符

使用 `RegExp.prototype.dotAll` 属性检查该正则是否是 `dotAll` 模式

```JavaScript
const re = /foo.bar/s;
// 另一种写法
// const re = new RegExp('foo.bar', 's');

re.test('foo\nbar') // true
re.dotAll // true
re.flags // 's'
```

先行断言和先行否定断言，括号中的部分不计入结果

```JavaScript
// 匹配必须在 % 之前的数字
/\d+(?=%)/.exec('100% of US presidents have been male')  // ["100"]
// 匹配必须不在 % 之前的数字
/\d+(?!%)/.exec('that’s all 44 of them')                 // ["44"]
```

新增的后行断言和后行否定断言，括号中的部分也不计入结果，会先匹配条件之后的字符，在回到括号内匹配括号内的部分，也就是“先右后左”，与其他正则相反，会导致一些奇怪的行为，并且反斜杠引用，也与通常的顺序相反

```JavaScript
// 匹配必须在 $ 之后的数字
/(?<=\$)\d+/.exec('Benjamin Franklin is on the $100 bill')  // ["100"]
// 匹配必须不在 $ 之后的数字
/(?<!\$)\d+/.exec('it’s is worth about €90')                // ["90"]

/(?<=(\d+)(\d+))$/.exec('1053') // ["", "1", "053"]
/^(\d+)(\d+)$/.exec('1053') // ["1053", "105", "3"]
```

`\p{...}` 和 `\P{...}`，允许正则表达式匹配符合 Unicode 某种属性的所有字符，大写的是小写的反向匹配，仅对 Unicode 有效，所以使用时必须带有 `u` 修饰符

```JavaScript
const regexGreekSymbol = /\p{Script=Greek}/u;
regexGreekSymbol.test('π') // true

\p{UnicodePropertyName=UnicodePropertyValue}

// 有的属性可以只写属性名或者属性值
\p{UnicodePropertyName}
\p{UnicodePropertyValue}

const regex = /^\p{Decimal_Number}+$/u;
regex.test('𝟏𝟐𝟑𝟜𝟝𝟞𝟩𝟪𝟫𝟬𝟭𝟮𝟯𝟺𝟻𝟼') // true
// 匹配所有数字
const regex = /^\p{Number}+$/u;
regex.test('²³¹¼½¾') // true
regex.test('㉛㉜㉝') // true
regex.test('ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩⅪⅫ') // true

// 匹配所有空格
\p{White_Space}

// 匹配各种文字的所有字母，等同于 Unicode 版的 \w
[\p{Alphabetic}\p{Mark}\p{Decimal_Number}\p{Connector_Punctuation}\p{Join_Control}]

// 匹配各种文字的所有非字母的字符，等同于 Unicode 版的 \W
[^\p{Alphabetic}\p{Mark}\p{Decimal_Number}\p{Connector_Punctuation}\p{Join_Control}]

// 匹配 Emoji
/\p{Emoji_Modifier_Base}\p{Emoji_Modifier}?|\p{Emoji_Presentation}|\p{Emoji}\uFE0F/gu

// 匹配所有的箭头字符
const regexArrows = /^\p{Block=Arrows}+$/u;
regexArrows.test('←↑→↓↔↕↖↗↘↙⇏⇐⇑⇒⇓⇔⇕⇖⇗⇘⇙⇧⇩') // true
```
